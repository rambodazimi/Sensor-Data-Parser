# Sensor-Data-Parser

<h3>Parsing sensor data logs for analysis</h3>

Description:

It is often necessary to parse the output produced by various specialized software systems to extract/generate data that is of specific interest to us. In this project, we will use the advanced Unix utilities to analyze the output files from a weather monitoring process.

The data files that we will be using for this assignment is available under the directory hierarchy of /home/2013/jdsilv2/206/m3/dataset1. Please note that this directory may not be accessible through FileZilla, etc. It is primarily meant to be accessed from the Unix command line in mimi.

The data files are generated by a program that reads five different temperature sensors followed by three wind speed sensors and one wind direction sensor once every hour (24 readings in a given day) and records these readings. The temperature sensors are a bit sensitive instruments, and as such sometimes do not provide data. If the program was unable to read a particular temperature sensor, it will indicate the corresponding sensor’s reading as NOINF or MISSED SYNC STEP. Luckily the wind sensors do not have any issues. Along with this, the program also logs various other information (such as performing diagnostics, etc.) which we are not concerned with (but is nevertheless present in the output file and may interfere with our data analysis).

A sample output of one of these data files is given below. (truncated for brevity). You can deduce the message formats from the data files given to you. Please note that positive temperature readings do not have an explicit + sign associated with them.

2022-01-24 00:05:25 observation line  -0.70 -1.38 -2.15 -2.67 -2.73 1 0 4 7

...

2022-01-24 03:01:28 performing diagnostics on temp. sensor: 4

2022-01-24 03:03:09 performing diagnostics on temp. sensor: 5

2022-01-24 03:07:25 observation line  -2.70 -2.88 -3.65 MISSED SYNC STEP MISSED SYNC STEP 3 4 7 7

2022-01-24 04:01:14 observation line  -3.70 -2.88 -3.65 -8.18 -5.72 8 6 7 7

2022-01-24 05:04:18 observation line [data log flushed]  -5.20 -2.88 -5.15 -8.18 -5.72 13 5 10 4

2022-01-24 06:03:08 observation line  -5.20 -2.38 -4.65 -7.18 -4.22 17 4 11 3

2022-01-24 07:03:50 active power disengaged

...

2022-01-24 16:00:08 performing diagnostics on temp. sensor: 3

2022-01-24 16:02:13 observation line [data log flushed]  2.30 4.62 NOINF -1.18 3.78 12 4 3 7

...

2022-01-24 23:01:34 performing diagnostics on temp. sensor: 4

2022-01-24 23:05:09 observation line  0.80 4.62 -0.15 MISSED SYNC STEP 3.28 5 0 7 0

You will be writing a shell script wparser.bash that would process these data files.

The shell script is expected to be given the name of a directory, under which it will start the search for data files whose names are of the form weather info *.data as its argument. (Do not hard code the directory name in your script).

If the script is not invoked with the correct number of arguments, it should throw an usage message and terminate with a code of 1.

If the passed argument is not a valid directory name, it should throw an error message and terminate with code 1. For this particular situation (and only here), the error message must be send to the standard error and not the standard output.

Within the shell script, use an appropriate Unix command to look for data files starting under the given directory hierarchy that matches the specific file name pattern mentioned above (keep in mind that the data files might be under some arbitrary subdirectories, etc.). Do not assume specific directory hierarchies. Each data file only contains the information for that specific day. And each day has its own data file and never spread across multiple data files. No points are awarded for this question even if you miss one valid data file or include data files which does not follow the pattern given to you.

Write a function extractData in your shell script wparser.bash. This function will perform the core processing logic associated with each file. The main script will just iteratively call this function with different files as its argument.

This function should accept a data file as its argument. This function should then produce an output of the following format that that contains only the temperature and wind information from the sensors along with a header. (Truncated for brevity). A clean format of data like this form can be used by various information processing systems.

Processing Data From  <path to the filename here>

====================================

Year,Month,Day,Hour,TempS1,TempS2,TempS3,TempS4,TempS5,WindS1,WindS2,WindS3,WinDir

2022,01,24,00,-0.70,-1.38,-2.15,-2.67,-2.73,1,0,4,NW

...

2022,01,24,04,-3.70,-2.88,-3.65,-8.18,-5.72,8,6,7,NW

2022,01,24,05,-5.20,-2.88,-5.15,-8.18,-5.72,13,5,10,S

2022,01,24,06,-5.20,-2.38,-4.65,-7.18,-4.22,17,4,11,SE

2022,01,24,07,-3.70,-2.38,-4.65,-6.68,-3.72,14,6,6,SE

...

2022,01,24,21,1.80,5.12,2.85,-1.68,3.28,4,4,5,SE

2022,01,24,22,0.80,5.12,1.35,-1.68,3.28,3,0,6,SE

2022,01,24,23,0.80,4.62,-0.15,-1.68,3.28,5,0,7,N

====================================

The script is basically only including the year, month, day and hour information, followed by the temperature reported by each temperature sensor, and wind speed from wind sensors at that time. If a temperature sensor’s reading is NOINF or MISSED SYNC STEP in the original data file for that particular time, the script must instead output the previous readout for that temperature sensor.

For simplicity, you can assume that the first readout for all the temperature sensors in a given day does not have any issues. The output should follow the same order of time as in the original data file.

The script also translates the wind speed direction codes (which runs from 0 through 7) to appropriate mnemonics, i.e. (N,NE,E,SE,S,SW,W,NW) respectively.

Immediately following the previous output produced from a data file, the script (aka inside the function to be specific) should produce the statistics as to what was the maximum as well as the minimum temperature and wind speed that was reported for a given hour. The format is given below. For this report, it is important to ignore the temperature sensors that it was not able to read data for that hour and consider only the sensors that were functioning and produced a valid reading in that hour.

Observation Summary

Year,Month,Day,Hour,MaxTemp,MinTemp,MaxWS,MinWS

2022,01,24,00,-0.70,-2.73,4,0

...

2022,01,24,06,-2.38,-7.18,17,4

2022,01,24,07,-2.38,-6.68,14,6

2022,01,24,08,-2.38,-5.18,12,2

2022,01,24,09,-1.38,-3.68,13,0

...

2022,01,24,23,4.62,-0.15,7,0

====================================

As in the previous case, the output should follow the same order of time as in the original data file.

Once the script is done producing the above two statistics for each data file, we want the script to report on the health of the temperature sensors across all those days (data files). The logic for this task is to be written as part of the main script itself (i.e., not inside the extractData function). For this purpose, we will have to count the number of times that each temperature sensor reported an error for each day. If a temperature sensor did not report an error, indicate with the value 0. The last field in each line is the total number of temperature sensor errors on that day (sum of the individual sensor errors). The output should be sorted such that the dates with the larger number of (total) errors on the top (descending order). If two (or more) dates have the same number of errors, then order their lines in the output in the chronological order of dates. (I.e. Jan 31 is before Feb 1, etc. if they both have same number of errors.)

This report, however, should be stored on to a file called sensorstats.html in the current directory. The format of this HTML file is very simple. You can vi the example format given to you to understand the format that you need to produce. If the file already exists, overwrite it.

<HTML>

<BODY>

<H2>Sensor error statistics</H2>

<TABLE>

<TR><TH>Year</TH>...<TH>Day</TH><TH>TempS1</TH>...<TH>TempS5</TH><TH>Total</TH><TR>

<TR><TD>2021</TD><TD>11</TD><TD>11</TD>...<TD>3</TD><TD>2</TD><TD>11</TD></TR>

...

</TABLE>

</BODY>

</HTML>



